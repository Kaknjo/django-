/----------------------------------------------------------------------------------*
	Django instalacija i podesavanje okoline za rad sa Djangom


/**********************************************************************************
-Instaliranje i podesavanje pip-a 

Potrebno prvo podesiti pip(python package menager) i preko njega instalirati i updateovati sve potrebne stvari. 

Instaliranje pip menagera za python2 

	sudo apt install python-pip

Instaliranje pip menagera za verziju python3

	sudo apt install python3-venv python3-pip

Preporuceno je koristit posljednju verziju pipa, upgrade se vrsi komandom 

	python3 -m pip install --user --upgrade pip

Provjera verzije pipa: 
	python3 -m pip --version
Trenutna verzija 
pip 19.1.1 from /home/kaknjo/.local/lib/python3.6/site-packages/pip (python 3.6)


Update na posljednju verziju 
	sudo apt-get update
	sudo apt-get install python3.7


Reference
 https://packaging.python.org/guides/installing-using-linux-tools/
https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/

virtualenv env

/*****************************************************************************/

Instaliranje i podesavanje virtualenv

pip install virutalenv komanda za instaliranje virutalenv

Ukoliko se koristi python3 venv  bi trebao vec biti instaliran sa standardnom bibliotekom, u nastavku ce se svugdje koristiti venv tool. 

Prvo kreirajmo datoteku koja ce se zvati python_virutal_enviroments i odmah se nagivirajmo u nju 
	mkdir python-virtual-environments && cd python-virtual-environments
Kreirajmo sada novi virtualenviroment u toj datoteci: 
*python2 
	virtualenv env
*python3
	python3 -m venv envir

Po defaultu kada se kreira nece ukljucivati niti jednom package. 
Kada smo kreirali stablo kreira se struktura slicna ovoj:
├── bin
│   ├── activate
│   ├── activate.csh
│   ├── activate.fish
│   ├── easy_install
│   ├── easy_install-3.5
│   ├── pip
│   ├── pip3
│   ├── pip3.5
│   ├── python -> python3.5
│   ├── python3 -> python3.5
│   └── python3.5 -> /Library/Frameworks/Python.framework/Versions/3.5/bin/python3.5
├── include
├── lib
│   └── python3.5
│       └── site-packages
└── pyvenv.cfg 
Svaki od njih sadrzi:

    bin: files that interact with the virtual environment
    include: C headers that compile the Python packages
    lib: a copy of the Python version along with a site-packages folder where each dependency is installed

Nakon toga potrebno je aktivirati skripte u bin envir/bin:
	 source env/bin/activate
Nakon toga sve sto radimo odnosi se samo lokalnoj na taj virtualenv, (envir) govori nam da se nalazimo u tom scopeu.
Za povratak u normal shell koristi se komanda: 
	deactivate

Za ispisivanej trenutne lokacije razlicitih python executables: 
	which python 
	/usr/bin/pytho- rezultat u normall shellu 

Sada kada udemo u virtualenv i koristimo whick python rezultat je sljedeci: 
	/home/kaknjo/python-virtual-environments/envir/bin/python
Kada aktiviramo viruelenv mozemo primjetiti da dobijamo drugaciji PATH. 

Kada pozovemo echo $PATH (komanda za ispis patha)
Path kada smo u virtualenv: 
	/home/kaknjo/python-virtual-environments/envir/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
Kada deaktiviramo virutalenv:
	/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin


Za laksi rad sa virutalenviromentima koristi se virtualenvwrapper: 
Neke od prednosti virutalenvwrappera :

    Organizes all of your virtual environments in one location
    Provides methods to help you easily create, delete, and copy environments
    Provides a single command to switch between environments

Potrebno je prvo skinuti virtualwrapper komanda koristeci pip: 
	$ pip install virtualenvwrapper

Nakon instalacije: 
	export WORKON_HOME=$HOME/.virtualenvs   # Optional
	export PROJECT_HOME=$HOME/projects      # Optional
	source ~/.local/bin/virtualenvwrapper.sh

Osnovne komande virutalenvwrapper: 
	mkvirutalenv kreiranje nove virtualenviroment
	workon- ispis i prebacivanje sa jedne na drugu virutalenv
	rmvirutalenv - brisanje 
	deactivate -  izlaz 

Moguce je koristiti i  za specificne verzije pythona:
	 virtualenv -p $(which python3)



Sada cemo kreirati posebnu virtualenv u koju cemo instalirati Django 
1 . Kreiramo virtualenviroment sa nazivom project_django 
	python3 -m venv site 
Aktiviramo virutalenv 
	source site/bin/activate
2. U site virtualenv instaliramo djang  
	 
*python2 
	pip install Django

*python3 
	pip3 install django 
Provjera Django verzije 
	pythom -m django --version 
3. Nakon instalacije u isti virtualenviroment pokrecemo django project komandom: 

	django-admin startproject mysite
4. Nakon toga mozemo pokrenuti server :
	django-admin manage.py runserver 
(razlika izmedu django-admina i manage.py https://docs.djangoproject.com/en/2.2/ref/django-admin/) 
Nakon toga na localhost:8000 bi trebali da dobijem pristuo nasem serveru. 
 *Greska koja se javljala i pravila problem kada se navigira na ~/python-virtual-environments/mysite potrebno je aktivirati i virutalenv u suptronom server nece raditi. 
	source site/bin/activate 

4. Kreiramo django app (razlika izmedu Django app i projecta https://www.quora.com/What%E2%80%99s-the-difference-between-a-project-and-an-app-in-Django-world) 
	python manage.py startapp polls 


Konfiguracija polls/views.py 
	from django.http import HttpResponse


	def index(request):
    		return HttpResponse("Hello, world. Dobro dosli na index page. ")


Konfiguracija mysite/urls.py. To call the view, we need to map it to a URL - and for this we need a URLconf.

	from django.urls import path

	from . import views

	urlpatterns = [
    	path('', views.index, name='index'),
	]

The next step is to point the root URLconf at the polls.urls module. In mysite/urls.py, add an import for django.urls.include and insert an include() in the urlpatterns list. 
Konfiguracija mysite/mysite/urls.py 
	from django.contrib import admin
	from django.urls import include, path

	urlpatterns = [
    	path('polls/', include('polls.urls')), 		
    	path('admin/', admin.site.urls),
	]

*Greska koja se pojavljivala  mora da se konfigurise mysite/mysite/urls.py ne mysite/urls.py 

Nakon ovoga kada pozovemo: 
	django-admin manage.py runserver
Server bi trebao biti pokrenut i ispisana poruka "Hello, world. Dobro dosli na index page. "
	

Turtorial za django polls app: 
https://docs.djangoproject.com/en/2.2/intro/tutorial01/


Reference:
https://realpython.com/python-virtual-environments-a-primer/
https://virtualenvwrapper.readthedocs.io/en/latest/install.html
https://stackoverflow.com/questions/12647266/where-is-virtualenvwrapper-sh-after-pip-install 
https://stackoverflow.com/questions/31274642/error-virtualenvwrapper-could-not-find-virtualenv-in-your-path - problem i rjesenje kod instaliranja virtualenvwrappera
https://www.digitalocean.com/community/tutorials/how-to-install-django-and-set-up-a-development-environment-on-ubuntu-16-04#step-3-%E2%80%94-install-django



	
Drugi dio tutoriala : 
Prije ovoga trebalo je promjeniti vremensku zonu u mysite/mysite/setting.py na Europe/Sarajevo. 
1) Prvo koristimo python manage.py migrate da kreiramo bazu 

2) Kreiramo moeld za pitanja i odgovore u polls/modells.py prema modelu da svako odgovara samo jednom pitanju. 
	from django.db import models



class Questions(models.Model):
	tekst_pitanja=models.charFileld(max_length=200)
	datum=models.dateTimeField('date published')


class Choice(models.Model):
	pitanje=models.ForeignKey(Question, on_delete=models.CASCADE)
	izbor_text=models.charFileld(max_length=200)
	glasovi=models.integerField(default=0)

4) Modele koje smo napisali potrebno je da aktiviramo. AKtivacijom dobijamo: 
	
    Create a database schema (CREATE TABLE statements) for this app.
    Create a Python database-access API for accessing Question and Choice objects.
Vrsimo tako sto cemo dodati path od polls appa u installed apps mysite/mysite/setting.py
Dodavanjem 'polls.apps.PollsConfig',u installed apps . 

Nakon toga komandom python  manage.py swlmigrate polls 0001 bi trebali da dobijemo sql kod baze.

python manage.py check komanda za provjeru problema .	

Reference: 
https://docs.djangoproject.com/en/2.2/intro/tutorial02/


API za interakciju sa bazom primjer: 
	Question.objects.all()- ispis pitanja iz klase Question 
	a=Question.objects.get(id=1) - sprema u a pitanje koje se nalazi na idu jedan 
	b=Question(question.text="Sta ima ? ") - dodavanje novog pitanja 
	Question.objects.filter(question_text__startswith='Sta') - vraca pitanja koja u sebi sadrze sta 
	q.choice_set.create(choice_text='Nista', votes=0) - postavljanje odgovora 


Kreiranje templatea , templeti u kombinacije html i python koda tempeti se kreiraju u direktoriju gdje se nalazi app. 
Kreira se direktorij pod nazivom templates i u njemu se kreira novi folder sa istim nazivom kao i app, i u tom direktoriju se kreiaju html fajlovi. 
Tako npr koristimo polls/index.html za poyiv odredenog templatea. 
Ya loaadanje tempplatea cesto se koristi funkcija render koja vraca htttp obradenog templaea. 
render() prima tri argumenta zahhtvjem template i context koji je opcionalni. 

U stvarnim sistema kada se koristi vise aplikacija moguce je da se dese isti url nazivi, stoga je dobra praksa stavljati i app_name np nazin applikacije na koju se odnosi. Tada url recimo ya polls u templateu polls/index.html umjesto <li><a href="{% url 'detail' question.id %}">{{ question.question_text }}</a></li> izgleda  <li><a href="{% url 'polls:detail' question.id %}">{{ question.question_text }}</a></li> sa dodanim nazivom appa ispred naziva urla. 



Reference: 
https://docs.djangoproject.com/en/2.2/intro/tutorial02/












